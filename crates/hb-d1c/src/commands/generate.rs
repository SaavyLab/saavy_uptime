use std::{
    collections::HashMap,
    fs,
    path::{Path, PathBuf},
};

use crate::{
    commands::{
        dump_schema::dump_schema,
        generate::{analyzer::analyze_query, parser::process_query_file, renderer::render_module},
    },
    utils::sql::collect_sql_files,
    D1CConfig,
};
use anyhow::Result;
use rusqlite::Connection;

mod analyzer;
mod parser;
mod renderer;
mod types;

pub fn run(conn: &Connection, config: &D1CConfig) -> Result<()> {
    let query_files = collect_sql_files(PathBuf::from(&config.queries_dir))?;
    let mut queries = Vec::new();
    for query_file in query_files {
        let parsed_queries = process_query_file(&query_file)?;
        queries.extend(parsed_queries);
    }

    for mut query in &mut queries {
        analyze_query(conn, &mut query)?;
    }

    // Group queries by source file
    let mut queries_by_file: HashMap<String, Vec<_>> = HashMap::new();
    for query in queries {
        queries_by_file
            .entry(query.source_file.clone())
            .or_default()
            .push(query);
    }

    let mut modules = Vec::new();

    // Generate root module name and submodule directory
    let root_file_name = if config.module_name.ends_with(".rs") {
        config.module_name.clone()
    } else {
        format!("{}.rs", config.module_name)
    };

    let root_module_stem = Path::new(&root_file_name)
        .file_stem()
        .unwrap()
        .to_string_lossy();

    // Submodules must be placed in a directory with the same name as the root module (minus .rs)
    // e.g. src/d1c/queries.rs -> src/d1c/queries/monitors.rs
    let submodule_dir = Path::new(&config.out_dir).join(root_module_stem.as_ref());
    fs::create_dir_all(&submodule_dir)?;

    for (file_name, file_queries) in queries_by_file {
        if file_name == "mod" {
            anyhow::bail!(
                "SQL file cannot be named 'mod.sql' as 'mod' is a reserved keyword in Rust"
            );
        }
        if file_name == root_module_stem {
            anyhow::bail!(
                "SQL file cannot be named '{}.sql' as it conflicts with the root module name",
                file_name
            );
        }

        let module_tokens = render_module(&file_queries, config.instrument_by_default)?;
        let ast = syn::parse2(module_tokens)?;
        let formatted = prettyplease::unparse(&ast);

        fs::write(submodule_dir.join(format!("{}.rs", file_name)), formatted)?;
        modules.push(file_name);
    }

    modules.sort();

    let mut root_content = String::new();
    root_content.push_str("// Auto-generated by d1c\n\n");
    for mod_name in modules {
        root_content.push_str(&format!("pub mod {};\n", mod_name));
    }

    fs::write(
        Path::new(&config.out_dir).join(root_file_name),
        root_content,
    )?;

    // Emit schema.sql if configured
    if config.emit_schema {
        let schema_rows = dump_schema(conn)?;
        let schema_string = schema_rows
            .iter()
            .map(|row| row.sql.clone())
            .collect::<Vec<String>>()
            .join("\n\n");
        // Ensure it ends with a newline for git friendliness
        let final_schema = if schema_string.is_empty() {
            schema_string
        } else {
            format!("{}\n", schema_string)
        };

        fs::write(
            Path::new(&config.queries_dir).join("schema.sql"),
            final_schema,
        )?;
    }

    Ok(())
}
