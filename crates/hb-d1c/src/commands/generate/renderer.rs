// generate/renderer.rs
use anyhow::{bail, Result};
use heck::{ToPascalCase, ToSnakeCase};
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote};

use crate::commands::generate::types::{Cardinality, Query};

pub fn render_module(queries: &[Query], instrument: bool) -> Result<TokenStream> {
    let mut blocks = Vec::with_capacity(queries.len());
    for q in queries {
        blocks.push(render_query_block(q, instrument)?);
    }
    Ok(quote! {
        // Auto-generated by d1c - DO NOT EDIT
        use worker::D1Database;
        use worker::Result;

        #(#blocks)*
    })
}

fn split_option_type(rust_type: &str) -> (bool, String) {
    let trimmed = rust_type.trim();
    if let Some(inner) = trimmed
        .strip_prefix("Option<")
        .and_then(|rest| rest.strip_suffix('>'))
    {
        (true, inner.trim().to_string())
    } else {
        (false, trimmed.to_string())
    }
}

fn argument_type_tokens(base: &str, is_option: bool) -> TokenStream {
    match base {
        "String" => {
            if is_option {
                quote! { Option<&str> }
            } else {
                quote! { &str }
            }
        }
        "Vec<u8>" => {
            if is_option {
                quote! { Option<&[u8]> }
            } else {
                quote! { &[u8] }
            }
        }
        _ => {
            let ty = format_ident!("{}", base);
            if is_option {
                quote! { Option<#ty> }
            } else {
                quote! { #ty }
            }
        }
    }
}

fn build_binding_expr(base: &str, is_option: bool, param_name: &Ident) -> TokenStream {
    if is_option {
        let inner_expr = base_binding_expr(base, quote! { value });
        quote! {
            match #param_name {
                Some(value) => {
                    #inner_expr
                }
                None => worker::wasm_bindgen::JsValue::NULL,
            }
        }
    } else {
        base_binding_expr(base, quote! { #param_name })
    }
}

fn base_binding_expr(base: &str, value: TokenStream) -> TokenStream {
    match base {
        "i64" => quote! { (#value as f64).into() },
        _ => quote! { #value.into() },
    }
}

fn render_query_block(query: &Query, instrument: bool) -> Result<TokenStream> {
    let row_struct = render_row_struct(query);
    let function = render_function(query, instrument)?;

    Ok(quote! {

        #row_struct

        #function

    })
}

fn render_row_struct(query: &Query) -> TokenStream {
    // Scalars don't get a struct, they use primitive types
    if matches!(query.cardinality, Cardinality::Scalar) {
        return TokenStream::new();
    }

    if query.columns.is_empty() {
        return TokenStream::new();
    }

    let struct_name = format_ident!("{}Row", &query.name.to_pascal_case());
    let fields = query.columns.iter().map(|col| {
        let ident = format_ident!("{}", &col.name.to_snake_case());
        let base_ty = format_ident!("{}", &col.rust_type);

        if col.not_null {
            quote! { pub #ident: #base_ty }
        } else {
            quote! { pub #ident: Option<#base_ty> }
        }
    });

    quote! {
        #[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
        pub struct #struct_name {
            #(#fields,)*
        }
    }
}

fn render_function(query: &Query, instrument: bool) -> Result<TokenStream> {
    let fn_name = format_ident!("{}", &query.name.to_snake_case());
    let sql = &query.transformed_sql;

    // Tracing instrumentation
    let instrument_attr = if instrument {
        let skip_d1 = quote! { d1 };
        let span_name = format!("d1c.{}", query.name.to_snake_case());

        let skip_list = if let Some(skips) = &query.instrument_skip {
            // If user put "*" or "skip_all", we skip all args?
            // For now, let's just handle explicit skips
            if skips.contains(&"*".to_string()) {
                // Skip all is tricky because we need to know arg names.
                // `tracing` doesn't support `skip_all`.
                // But we can skip known params.
                // For now, let's assume manual list.
                //
                // Actually, if "*" is present, we can iterate over all params and add them.
                if let Some(params) = &query.params {
                    let all_params = params
                        .iter()
                        .map(|p| format_ident!("{}", p.name.to_snake_case()));
                    quote! { skip(#skip_d1, #(#all_params),*) }
                } else {
                    quote! { skip(#skip_d1) }
                }
            } else {
                // Validate that skipped fields exist in params
                let valid_params: std::collections::HashSet<_> = query
                    .params
                    .as_ref()
                    .map(|p| p.iter().map(|param| param.name.as_str()).collect())
                    .unwrap_or_default();

                let mut skip_idents = Vec::new();
                for s in skips {
                    if !valid_params.contains(s.as_str()) {
                        bail!(
                            "Query '{}' skips parameter '{}' which is not defined.",
                            query.name,
                            s
                        );
                    }
                    skip_idents.push(format_ident!("{}", s.to_snake_case()));
                }

                quote! { skip(#skip_d1, #(#skip_idents),*) }
            }
        } else {
            quote! { skip(#skip_d1) }
        };

        quote! {
            #[tracing::instrument(name = #span_name, #skip_list)]
        }
    } else {
        quote! {}
    };

    // Determine the return type of the row/scalar
    // For scalar, it is the rust type of the first column
    let row_type_ident = if matches!(query.cardinality, Cardinality::Scalar) {
        if let Some(col) = query.columns.first() {
            format_ident!("{}", col.rust_type)
        } else {
            // Should be unreachable due to analyzer validation
            format_ident!("String")
        }
    } else {
        format_ident!("{}Row", &query.name.to_pascal_case())
    };

    // 1. Generate Function Arguments (Positional)
    let mut func_args = Vec::new();
    let mut bind_args = Vec::new();
    let mut call_args = Vec::new();

    if let Some(params) = &query.params {
        for param in params {
            let param_name = format_ident!("{}", param.name.to_snake_case());
            let (is_option, base_type) = split_option_type(param.rust_type.as_str());

            let arg_type = argument_type_tokens(&base_type, is_option);
            let binding_expr = build_binding_expr(&base_type, is_option, &param_name);

            func_args.push(quote! { #param_name: #arg_type });
            bind_args.push(binding_expr);
            call_args.push(quote! { #param_name });
        }
    }

    // 2. Bind Logic
    let bind_logic = if !bind_args.is_empty() {
        quote! {
            let stmt = stmt.bind(&[#(#bind_args),*])?;
        }
    } else {
        quote! {}
    };

    let exec_logic = match query.cardinality {
        Cardinality::One => quote! {
            let result = stmt.first::<#row_type_ident>(None).await?;
            Ok(result)
        },
        Cardinality::Many => quote! {
            let result = stmt.all().await?;
            let rows = result.results::<#row_type_ident>()?;
            Ok(rows)
        },
        Cardinality::Exec => quote! {
            stmt.run().await?;
            Ok(())
        },
        Cardinality::Scalar => {
            // For scalar, we need a temporary struct to deserialize because D1 returns objects
            // But wait! D1's .first(None) can return primitive types if the column is anonymous?
            // Actually, the safest way in worker-rs to get a scalar is to use .first::<T>(col_name).
            // But we don't want to depend on column names if possible.
            //
            // However, `stmt.first::<i64>(None)` works if the result is a single column row.
            // Let's rely on worker-rs's ability to deserialize a single value if it matches.
            // If not, we might need a wrapper struct.
            //
            // Re-reading worker-rs docs: `query.first::<T>(col)`
            // If T is a struct, it maps fields.
            // If T is a primitive, it expects the first column?
            //
            // Actually, in most D1 drivers, you get a JSON object `{ "count(*)": 5 }`.
            // Deserializing that into `i64` fails. You need a struct or a HashMap.
            //
            // HACK: We define a private, temporary struct inside the function to handle the deserialization,
            // then map it to the scalar.

            let col_name = query
                .columns
                .first()
                .map(|c| c.name.as_str())
                .unwrap_or("val");
            // If the column name is dynamic (like count(*)), we might have trouble.
            // But we can just use `serde_json::Value` or `HashMap`.
            //
            // Better yet: Use a struct with a single field that matches the column name?
            // But if the column name is `count(*)` that is not a valid struct field.
            //
            // Solution: `stmt.raw::<Vec<T>>()` exists? No.
            //
            // Let's assume for now that `stmt.first::<T>(Some("col_name"))` works if we know the column name.

            quote! {
                 // We need to fetch the value by column name because the JSON key is the column name
                 let result = stmt.first::<#row_type_ident>(Some(#col_name)).await?;
                 Ok(result)
            }
        }
    };

    let result_type = match query.cardinality {
        Cardinality::One => quote! { Result<Option<#row_type_ident>> },
        Cardinality::Many => quote! { Result<Vec<#row_type_ident>> },
        Cardinality::Exec => quote! { Result<()> },
        Cardinality::Scalar => quote! { Result<Option<#row_type_ident>> },
    };

    if query.gen_stmt {
        let stmt_fn_name = format_ident!("{}_stmt", &query.name.to_snake_case());
        let stmt_fn = quote! {
            pub fn #stmt_fn_name(d1: &D1Database, #(#func_args),*) -> Result<worker::D1PreparedStatement> {
                let stmt = d1.prepare(#sql);
                #bind_logic
                Ok(stmt)
            }
        };

        Ok(quote! {
            #stmt_fn

            #instrument_attr
            pub async fn #fn_name(d1: &D1Database, #(#func_args),*) -> #result_type {
                let stmt = #stmt_fn_name(d1, #(#call_args),*)?;
                #exec_logic
            }
        })
    } else {
        Ok(quote! {
            #instrument_attr
            pub async fn #fn_name(d1: &D1Database, #(#func_args),*) -> #result_type {
                let stmt = d1.prepare(#sql);
                #bind_logic
                #exec_logic
            }
        })
    }
}
