# d1c

**Type-safe SQL queries for Cloudflare D1 + Rust Workers**

d1c generates compile-time checked Rust functions from your SQL queries, eliminating an entire class of bugs while keeping your Worker bundles tiny. Think `sqlc` for Go, but designed specifically for Cloudflare's edge platform.

```rust
// db/queries/monitors.sql
-- name: ListMonitors :many
SELECT id, name, enabled FROM monitors WHERE org_id = :org_id;

// Generated code you get to use:
let monitors = queries::list_monitors(&d1, org_id).await?;
//                                    ^^^ type-safe, compile-time checked
```

No more positional parameter bugs. No more manual JSON parsing. No more typos in column names discovered at runtime. Just clean, fast, safe code.

> **Status:** Early development. Core codegen works, type inference is solid, but expect the CLI and query format to evolve as we learn from real-world use.

---

## Why d1c?

**If you're building on Cloudflare Workers with D1, you've probably written code like this:**

```rust
let result = d1.prepare("SELECT * FROM monitors WHERE org_id = ?1")
    .bind(&[org_id.into()])?  // positional params = footgun
    .all()
    .await?;

// Now manually parse untyped JSON...
for row in result.results {
    let id = row.get("id").ok_or("missing id")?;
    let name = row.get("name").ok_or("missing name")?;
    // repeat 10x, hope you spelled everything right
}
```

**Problems:**
- Positional parameters (`?1`, `?2`) are error-prone
- Column names are stringsâ€”typos become runtime panics
- No compile-time verification that your query matches your schema
- Manual JSON parsing is boilerplate-heavy
- Refactoring is scary (did you update all 47 queries?)

**With d1c:**

```rust
let monitors = queries::list_monitors(&d1, org_id).await?;
// That's it. Type-safe, compile-time checked, zero boilerplate.
```

**Benefits:**
- âœ… Named parameters (`:org_id` instead of `?1`)
- âœ… Typed result structs (no manual JSON parsing)
- âœ… Compile-time schema validation (typos fail at build time)
- âœ… Tiny generated code (WASM-friendly, no runtime overhead)
- âœ… Refactoring is safe (compiler catches schema changes)

---

## How It Works

d1c treats your **Wrangler migration files** as the source of truth:

```
1. Read your db/migrations/*.sql files
   â””â”€â†’ (these are the same migrations wrangler d1 migrations apply uses)

2. Replay them into a local SQLite database
   â””â”€â†’ (gives us a schema that exactly matches your D1 database)

3. Read your db/queries/*.sql files
   â””â”€â†’ (user-written queries with -- name: headers)

4. Generate typed Rust functions
   â””â”€â†’ (compile-time checked against the schema)
```

**Key insight:** Cloudflare D1 is SQLite. By using a local SQLite database for introspection, we get 100% faithful type information without ever touching your production D1.

---

## Quick Start

### Installation

```bash
cargo install d1c
```

### First Time Setup
```bash
cd your-worker-project
d1c init
```

This will:
- âœ… Read your `wrangler.toml` to find migrations
- âœ… Suggest sensible paths for queries and generated code  
- âœ… Create `d1c.toml` with everything configured
- âœ… Add an example query file to get you started

Then just:
```bash
d1c generate
```

and you're ready to write type-safe queries.

### Write a query

```sql
-- db/queries/monitors.sql

-- name: GetMonitor :one
SELECT id, name, url, interval_s, enabled
FROM monitors
WHERE id = :id;

-- name: ListMonitorsByOrg :many
SELECT id, name, enabled
FROM monitors
WHERE org_id = :org_id
ORDER BY name;

-- name: CreateMonitor :one
INSERT INTO monitors (id, org_id, name, url, interval_s, enabled)
VALUES (:id, :org_id, :name, :url, :interval_s, :enabled)
RETURNING *;

-- name: UpdateMonitorEnabled :exec
UPDATE monitors
SET enabled = :enabled
WHERE id = :id;
```

### Generate code

```bash
d1c generate
```

This creates `src/db/queries.rs`:

```rust
// Auto-generated by d1c - DO NOT EDIT

use worker::D1Database;

#[derive(Debug, Clone)]
pub struct GetMonitorRow {
    pub id: String,
    pub name: String,
    pub url: String,
    pub interval_s: i64,
    pub enabled: bool,
}

pub async fn get_monitor(
    d1: &D1Database,
    id: &str,
) -> worker::Result<Option<GetMonitorRow>> {
    // ... generated implementation
}

#[derive(Debug, Clone)]
pub struct ListMonitorsByOrgRow {
    pub id: String,
    pub name: String,
    pub enabled: bool,
}

pub async fn list_monitors_by_org(
    d1: &D1Database,
    org_id: &str,
) -> worker::Result<Vec<ListMonitorsByOrgRow>> {
    // ... generated implementation
}

// ... more functions
```

### Use it in your Worker

```rust
use crate::db::queries;

#[worker::event(fetch)]
async fn fetch(req: Request, env: Env, _ctx: Context) -> Result<Response> {
    let d1 = env.d1("DB")?;
    
    // Type-safe, compile-time checked queries
    let monitor = queries::get_monitor(&d1, "mon_123").await?;
    let all_monitors = queries::list_monitors_by_org(&d1, "org_456").await?;
    
    // Compiler enforces correct parameters
    queries::create_monitor(
        &d1,
        "mon_789",
        "org_456",
        "API Health",
        "https://api.example.com/health",
        60,
        true,
    ).await?;
    
    Response::ok("done")
}
```

---

## Query Format

Queries use special comment headers to specify behavior:

```sql
-- name: FunctionName :cardinality
-- ^ function name    ^ :one | :many | :exec | :scalar
```

**Cardinalities:**

- `:one` â€“ Returns `Result<Option<Row>>` (expects 0 or 1 results)
- `:many` â€“ Returns `Result<Vec<Row>>` (any number of results)
- `:exec` â€“ Returns `Result<()>` (for INSERT/UPDATE/DELETE without RETURNING)
- `:scalar` â€“ Returns `Result<Option<T>>` (for single-column results like `COUNT(*)`)

**Named parameters:**

Use `:param_name` in your queries:

```sql
-- name: FindUser :one
SELECT * FROM users
WHERE email = :email AND active = :active;
```

Becomes:

```rust
pub async fn find_user(
    d1: &D1Database,
    email: &str,
    active: bool,
) -> worker::Result<Option<FindUserRow>>
```

d1c rewrites named parameters to positional parameters behind the scenes, so you get the ergonomics without the runtime cost.

---

## Why Not Just Use...?

### sqlx?

sqlx is excellent for traditional Rust apps, but:
- âŒ Requires a runtime connection pool (doesn't fit Workers)
- âŒ Heavy macro machinery increases compile times
- âŒ Designed for long-running servers, not edge functions

d1c generates static code at build timeâ€”zero runtime overhead, perfect for WASM.

### diesel?

diesel is a full ORM:
- âŒ Large dependency tree (bloats WASM bundles)
- âŒ Schema-first (not migration-first like Wrangler requires)
- âŒ Designed for application servers, not serverless

d1c is just codegen, not an ORM. Tiny output, no runtime.

### Raw D1 bindings?

You can absolutely use `worker::D1Database` directly:
- âœ… Zero dependencies
- âŒ Positional parameters are error-prone
- âŒ Manual JSON parsing everywhere
- âŒ No compile-time safety
- âŒ Refactoring is dangerous

d1c gives you the safety without the weight.

---

## Project Philosophy

**Small scope, done well:**
- âœ… Only does codegen (doesn't run migrations)
- âœ… Only targets D1 (not a generic SQL tool)
- âœ… Only generates Rust (not a multi-language tool)

**Cloudflare-native:**
- âœ… Treats Wrangler migrations as source of truth
- âœ… Generates code for `worker::D1Database`
- âœ… Optimized for WASM bundle size

**Rust-friendly:**
- âœ… Generates idiomatic Rust (not translated Go)
- âœ… Works with standard Cargo workflows
- âœ… Committed generated code (like protobuf)

**Out of scope:**
- âŒ Not a migration runner (Wrangler owns that)
- âŒ Not an ORM (just typed queries)
- âŒ Not a remote DB tool (only introspects locally)

---

## Comparison to sqlc

d1c is heavily inspired by [sqlc](https://sqlc.dev), but adapted for Rust + Cloudflare:

| Feature | sqlc (Go) | d1c (Rust) |
|---------|-----------|------------|
| Query syntax | `-- name:` comments | Same |
| Named params | `:param` or `@param` | `:param` only |
| Schema source | `schema.sql` or migrations | Wrangler migrations |
| Target runtime | Go stdlib `database/sql` | `worker::D1Database` |
| Bundle size | Not a concern (server binary) | Critical (WASM) |

d1c keeps the good parts (typed queries from SQL) while respecting Workers' constraints (small bundles, edge runtime, Wrangler workflow).

---

## Commands

### `d1c init`

Initialize `d1c.toml` in your project.

```bash
d1c init
```

### `d1c generate`

Generate Rust code from your queries. It also updates `schema.sql` in your queries directory for reference.

```bash
d1c generate
```

Options:
- `gen` â€“ Alias for `generate`

### `d1c watch`

Watch your queries directory for changes and automatically regenerate bindings (and `schema.sql`).

```bash
d1c watch
```

This creates a long-running process that listens for file system events. It debounces rapid changes to prevent redundant builds.

### `d1c dump-schema`

Export the current schema as SQL to stdout.

```bash
d1c dump-schema > db/schema.sql
```

This shows you exactly what d1c sees after applying your migrations.

---

## Configuration

Create `d1c.toml` in your project root:

```toml
# Required: where your Wrangler migration files live
migrations_dir = "db/migrations"

# Required: where your query files are
queries_dir = "db/queries"

# Required: where to write generated Rust code
codegen_dir = "src/d1c"

# Optional: module name for generated code (default: "d1c")
module_name = "d1c"

# Optional: automatically instrument generated functions with tracing (default: false)
# Requires the `tracing` crate in your dependencies.
instrument_by_default = true
```

---

## Advanced Features

### Tracing Integration

d1c supports `tracing` out of the box. When enabled, generated functions are annotated with `#[tracing::instrument]`.

To enable:
1. Add `instrument_by_default = true` to your `d1c.toml` (or answer "Yes" during `d1c init`).
2. Ensure `tracing` is in your `Cargo.toml`.

By default, all arguments (except the `d1` connection) are included in the span. To skip specific sensitive or large arguments, use the `-- instrument:` header:

```sql
-- name: LoginUser :one
-- instrument: skip(password_hash)
SELECT * FROM users WHERE email = :email AND password_hash = :password_hash;
```

This generates:
```rust
#[tracing::instrument(name = "d1c.login_user", skip(d1, password_hash))]
pub async fn login_user(...) { ... }
```

### Explicit Parameter Types

Sometimes d1c's type inference isn't enough, or you want to enforce specific Rust types (e.g., using a newtype wrapper or handling a complex expression). You can use the `-- params:` header:

```sql
-- name: GetUserBalance :one
-- params: user_id UserId, currency String
SELECT balance FROM accounts WHERE user_id = :user_id AND currency = :currency;
```

d1c will use the types you specify exactly as written. Note that you are responsible for ensuring these types are in scope (e.g., by importing them in `src/db/mod.rs` or using fully qualified paths).

---

## Workflow

1. **Write migrations** (just like you already do):
   ```sql
   -- db/migrations/0001_create_monitors.sql
   CREATE TABLE monitors (
     id TEXT PRIMARY KEY,
     org_id TEXT NOT NULL,
     name TEXT NOT NULL,
     ...
   );
   ```

2. **Apply migrations** (via Wrangler):
   ```bash
   wrangler d1 migrations apply DB --local
   wrangler d1 migrations apply DB --remote
   ```

3. **Write queries**:
   ```sql
   -- db/queries/monitors.sql
   -- name: ListMonitors :many
   SELECT * FROM monitors WHERE org_id = :org_id;
   ```

4. **Generate code**:
   ```bash
   d1c generate
   ```

5. **Use in your Worker**:
   ```rust
   let monitors = queries::list_monitors(&d1, org_id).await?;
   ```

6. **Commit generated code**:
   ```bash
   git add src/d1c/d1c.rs
   git commit -m "Update queries"
   ```

Generated code is committed just like protobufâ€”it's part of your source tree, not a build artifact.

---

## Limitations

**Current:**
- Only supports SQLite types (D1 is SQLite, so this is fine)
- No transaction helpers (use D1's batch API directly)
- No connection pooling (Workers are stateless anyway)
- Query parsing is simple (doesn't handle every SQL edge case)

**Future:**
- Better type inference for expressions
- Support for D1's upcoming features (vectors, etc.)
- Optional runtime helpers (if there's demand)

---

## Examples

See the [examples/](examples/) directory for full working demos:

- `basic/` â€“ Simple CRUD operations
- `saavy-uptime/` â€“ Real-world usage in a production app
- `relations/` â€“ JOINs and foreign keys

---

## Contributing

d1c is young and opinionated. If you're building on D1 + Rust and hit rough edges, we'd love to hear about it:

- **File issues** for bugs, confusing errors, or missing features
- **Share your queries** if d1c can't handle them (helps us improve)
- **Contribute docs** for common patterns or gotchas

We're especially interested in feedback from people using D1 in production Workers.

---

## Inspiration

- **[sqlc](https://sqlc.dev)** â€“ Proved that codegen from SQL beats ORMs for many use cases
- **Cloudflare's D1 team** â€“ For building SQLite at the edge
- **The Rust community** â€“ For showing that type safety doesn't have to sacrifice ergonomics

---

## License

MIT

---

Built for teams running serious workloads on Cloudflare Workers who want the safety of Rust without the boilerplate of raw SQL strings. If you're tired of positional parameter bugs and manual JSON parsing, give d1c a try.

**Let's make D1 queries as type-safe as the rest of your Rust code.** ðŸš€