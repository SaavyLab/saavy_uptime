// generate/renderer.rs
use heck::{ToPascalCase, ToSnakeCase};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::commands::generate::types::{Cardinality, Query};

pub fn render_module(queries: &[Query]) -> TokenStream {
    let blocks = queries.iter().map(render_query_block);
    quote! {
        // Auto-generated by d1c - DO NOT EDIT
        use worker::D1Database;
        use worker::Result;

        #(#blocks)*
    }
}

fn render_query_block(query: &Query) -> TokenStream {
    let row_struct = render_row_struct(query);
    let (params_struct, params_arg) = render_params_struct(query);
    let function = render_function(query, params_arg);

    quote! {

        #row_struct

        #params_struct

        #function

    }
}

fn render_row_struct(query: &Query) -> TokenStream {
    if query.columns.is_empty() {
        return TokenStream::new();
    }

    let struct_name = format_ident!("{}Row", &query.name.to_pascal_case());
    let fields = query.columns.iter().map(|col| {
        let ident = format_ident!("{}", &col.name.to_snake_case());
        let ty = format_ident!("{}", &col.rust_type);
        // D1 columns might be null, so we wrap in Option unless we know better
        // For now, let's assume standard types, but in prod you might want Option<T>
        quote! { pub #ident: #ty }
    });

    quote! {
        #[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
        pub struct #struct_name {
            #(#fields,)*
        }
    }
}

fn render_function(query: &Query, params_arg: TokenStream) -> TokenStream {
    let fn_name = format_ident!("{}", &query.name.to_snake_case());
    let row_type = format_ident!("{}Row", &query.name.to_pascal_case());
    let sql = &query.transformed_sql; // Use the SQL with ? placeholders

    // Generate the bind list: &[&params.id.into(), &params.name.into()]
    let bind_logic = if let Some(params) = &query.params {
        let param_fields = params.iter().map(|p| {
            let name = format_ident!("{}", p.name.to_snake_case());
            quote! { &params.#name.into() }
        });
        quote! {
            let stmt = stmt.bind(&[#(#param_fields),*])?;
        }
    } else {
        quote! {}
    };

    let exec_logic = match query.cardinality {
        Cardinality::One => quote! {
            let result = stmt.first::<#row_type>(None).await?;
            Ok(result)
        },
        Cardinality::Many => quote! {
            let result = stmt.all().await?;
            let rows = result.results::<#row_type>()?;
            Ok(rows)
        },
        Cardinality::Exec => quote! {
            stmt.run().await?;
            Ok(())
        },
        Cardinality::Scalar => quote! {
            // Scalar is tricky in D1, usually involves getting the first column of first row
            // For MVP, treating as :one usually works if struct has 1 field
            let result = stmt.first::<#row_type>(None).await?;
            Ok(result.map(|r| r.val)) // Assuming the column is named 'val' or we unwrap the struct
        },
    };

    let result_type = match query.cardinality {
        Cardinality::One => quote! { Result<Option<#row_type>> },
        Cardinality::Many => quote! { Result<Vec<#row_type>> },
        Cardinality::Exec => quote! { Result<()> },
        // Simplification for now:
        Cardinality::Scalar => quote! { Result<Option<#row_type>> }, 
    };

    quote! {
        pub async fn #fn_name(d1: &D1Database #params_arg) -> #result_type {
            let stmt = d1.prepare(#sql);
            #bind_logic
            #exec_logic
        }
    }
}

fn render_params_struct(query: &Query) -> (TokenStream, TokenStream) {
    if let Some(params) = &query.params {
        let struct_name = format_ident!("{}Params", &query.name.to_pascal_case());
        let fields = params.iter().map(|param| {
            let ident = format_ident!("{}", param.name.to_snake_case());
            let ty_ident = format_ident!("{}", param.rust_type);
            quote! { pub #ident: #ty_ident }
        });

        let struct_tokens = quote! {
            #[derive(Debug, Clone)]
            pub struct #struct_name {
                #(#fields,)*
            }
        };

        let params_arg = quote! { , params: &#struct_name };
        (struct_tokens, params_arg)
    } else {
        (TokenStream::new(), TokenStream::new())
    }
}