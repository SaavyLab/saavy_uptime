use heck::{ToPascalCase, ToSnakeCase};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::commands::generate::types::{Cardinality, Query};

pub fn render_module(queries: &[Query]) -> TokenStream {
    let blocks = queries.iter().map(render_query_block);
    quote! {
        // Auto-generated by d1c - DO NOT EDIT
        use worker::D1Database;
        use worker::Result;

        #(#blocks)*
    }
}

fn render_query_block(query: &Query) -> TokenStream {
    let row_struct = render_row_struct(query);
    let (params_struct, params_arg) = render_params_struct(query);
    let function = render_function(query, params_arg);

    quote! {
        #row_struct
        #params_struct
        #function
    }
}

fn render_row_struct(query: &Query) -> TokenStream {
    if query.columns.is_empty() {
        return TokenStream::new();
    }

    let struct_name = format_ident!("{}QueryResult", &query.name.to_pascal_case());
    let fields = query.columns.iter().map(|col| {
        let ident = format_ident!("{}", &col.name.to_snake_case());
        let ty = format_ident!("{}", &col.rust_type);
        quote! { pub #ident: #ty }
    });

    quote! {
        #[derive(Debug, Clone)]
        pub struct #struct_name {
            #(#fields,)*
        }
    }
}

fn render_function(query: &Query, params_arg: TokenStream) -> TokenStream {
    let fn_name = format_ident!("{}", &query.name.to_snake_case());
    let row_type = format_ident!("{}QueryResult", &query.name.to_pascal_case());

    let sql = query.sql_text();
    let body = quote! {
        let stmt = d1.prepare(#sql)?;
        let rows = stmt.all()?.unwrap();
        Ok(rows)
    };

    let result_type = match query.cardinality {
        Cardinality::One => quote! { Result<Option<#row_type>> },
        Cardinality::Many => quote! { Result<Vec<#row_type>> },
        Cardinality::Exec => quote! { Result<()> },
        Cardinality::Scalar => quote! { Result<Option<T>> },
    };

    quote! {
        pub async fn #fn_name(d1: &D1Database #params_arg) -> #result_type {
            #body
        }
    }
}

fn render_params_struct(query: &Query) -> (TokenStream, TokenStream) {
    if let Some(params) = &query.params {
        let struct_name = format_ident!("{}QueryParams", &query.name.to_pascal_case());
        let fields = params.iter().map(|param| {
            let ident = format_ident!("{}", param.name.to_snake_case());
            let ty_ident = format_ident!("{}", param.rust_type);
            quote! { pub #ident: #ty_ident }
        });

        let struct_tokens = quote! {
            #[derive(Debug, Clone)]
            pub struct #struct_name {
                #(#fields,)*
            }
        };

        let params_arg = quote! { , params: &#struct_name };
        (struct_tokens, params_arg)
    } else {
        (TokenStream::new(), TokenStream::new())
    }
}
