use anyhow::Result;
use heck::{ToPascalCase, ToSnakeCase};
use std::fmt::Write;
use crate::commands::generate::types::{ParsedQuery, QueryInfo, Cardinality};

pub fn generate_queries_file(functions: &Vec<String>) -> Result<String> {
    let mut w = String::new();
    writeln!(&mut w, "// Auto-generated by d1c - DO NOT EDIT")?;
    writeln!(&mut w, "use worker::D1Database;")?;
    for function in functions {
        writeln!(&mut w, "{}", function)?;
    }
    Ok(w)
}

pub fn generate_query_function(query: &ParsedQuery, query_info: &QueryInfo) -> Result<String> {
    let mut w= String::new();
    writeln!(&mut w)?;
    writeln!(&mut w, "pub struct {}QueryResult {{", query.name.to_pascal_case())?;
    for column in &query_info.columns {
        writeln!(&mut w, "    pub {}: {},", column.name, column.rust_type)?;
    }

    writeln!(&mut w, "}}")?;
    writeln!(&mut w)?;
    let mut signature_params = String::new();
    if let Some(params) = &query.params {
        let param_struct = format!("{}QueryParams", query.name.to_pascal_case());
        writeln!(&mut w, "#[derive(Debug, Clone)]")?;
        writeln!(&mut w, "pub struct {} {{", param_struct)?;
        for param in params {
            writeln!(&mut w, "    pub {}: {},", param.name, param.rust_type)?;
        }
        writeln!(&mut w, "}}")?;
        signature_params = format!(", params: &{}", param_struct);
    }

    writeln!(&mut w)?;
    
    match query.cardinality {
        Cardinality::One => {
            writeln!(&mut w, "pub async fn {}(d1: &D1Database{}) -> worker::Result<Option<Row>> {{", query.name.to_snake_case(), signature_params)?;
        }
        Cardinality::Many => {
            writeln!(&mut w, "pub async fn {}(d1: &D1Database{}) -> worker::Result<Vec<Row>> {{", query.name, signature_params)?;
        }
        Cardinality::Exec => {
            writeln!(&mut w, "pub async fn {}(d1: &D1Database{}) -> worker::Result<()> {{", query.name, signature_params)?;
        }
        Cardinality::Scalar => {
            writeln!(&mut w, "pub async fn {}(d1: &D1Database{}) -> worker::Result<Option<T>> {{", query.name, signature_params)?;
        }
    }

    writeln!(&mut w, "    let stmt = d1.prepare(\"{}\");", query.sql.join("\n"))?;

    match query.cardinality {
        Cardinality::One => {
            writeln!(&mut w, "    let result = stmt.first()?.unwrap();")?;
        }
        Cardinality::Many => {
            writeln!(&mut w, "    let result = stmt.all()?.unwrap();")?;
        }
        Cardinality::Exec => {
            writeln!(&mut w, "    let result = stmt.exec()?.unwrap();")?;
        }
        Cardinality::Scalar => {
            writeln!(&mut w, "    let result = stmt.scalar()?.unwrap();")?;
        }
    }
    writeln!(&mut w, "    Ok(result)")?;
    writeln!(&mut w, "}}")?;
    Ok(w)
}